"use strict";
const parser_node_1 = require("./parser-node");
const issue_1 = require("./issue");
/**
 *  Helper to maintain the current state of open tags
 */
class ParserState {
    constructor(scopes, voids) {
        this.mismatchCount = 0;
        if (scopes == null)
            scopes = ['html', 'body', 'template', 'svg', 'math'];
        if (voids == null)
            voids = ['area', 'base', 'br', 'col', 'embed', 'hr',
                'img', 'input', 'keygen', 'link', 'meta',
                'param', 'source', 'track', 'wbr'];
        this.scopes = scopes;
        this.voids = voids;
    }
    initPreRules(parser) {
        this.stack = [];
        this.issues = [];
        var stack = this.stack;
        this.mismatchCount = 0;
        parser.on("startTag", (name, attrs, selfClosing, location) => {
            this.nextScope = null;
            this.nextNode = null;
            if (stack.length > 0 && stack[stack.length - 1].isVoid) {
                this.popStack();
            }
            let isVoid = this.isVoid(name);
            if (!selfClosing) {
                let currentScope = this.scope;
                let nextScope = "";
                if (stack.length > 0)
                    nextScope = stack[stack.length - 1].scope;
                if (this.isScope(name))
                    nextScope = name;
                this.nextScope = nextScope;
                this.nextNode = new parser_node_1.ParserNode(this.nextScope, name, attrs, isVoid, location);
            }
        });
        parser.on("endTag", (name, loc) => {
            if (stack.length > 0 && stack[stack.length - 1].isVoid) {
                this.popStack();
            }
            if (this.isVoid(name)) {
                let issue = new issue_1.Issue({
                    message: "void elements should not have a closing tag",
                    line: loc.line,
                    column: loc.col,
                    severity: issue_1.IssueSeverity.Error,
                    start: loc.startOffset,
                    end: loc.endOffset
                });
                this.issues.push(issue);
            }
            else if (stack.length <= 0 || stack[stack.length - 1].name != name) {
                if (this.mismatchCount < 5) {
                    let issue = new issue_1.Issue({
                        message: "mismatched close tag",
                        line: loc.line,
                        column: loc.col,
                        severity: issue_1.IssueSeverity.Error,
                        start: loc.startOffset,
                        end: loc.endOffset
                    });
                    this.issues.push(issue);
                }
                else if (this.mismatchCount == 5) {
                    let issue = new issue_1.Issue({
                        message: "too many mismatched close tags",
                        line: loc.line,
                        column: loc.col,
                        severity: issue_1.IssueSeverity.Fatal,
                        start: loc.startOffset,
                        end: loc.endOffset
                    });
                    this.issues.push(issue);
                }
                this.mismatchCount += 1;
            }
            else {
                this.popStack();
            }
        });
    }
    initPostRules(parser) {
        var self = this;
        parser.on("startTag", () => {
            if (self.nextScope !== null)
                self.scope = self.nextScope;
            self.nextScope = null;
            if (self.nextNode != null)
                self.stack.push(self.nextNode);
            self.nextNode = null;
        });
    }
    finalise() {
        let stack = this.stack;
        if (stack.length > 0) {
            let element = stack[stack.length - 1];
            let issue = new issue_1.Issue({
                message: "suspected unclosed element detected",
                severity: issue_1.IssueSeverity.Error,
                line: element.location.line,
                column: element.location.col,
                start: element.location.startOffset,
                end: element.location.endOffset
            });
            this.issues.push(issue);
        }
    }
    isVoid(name) {
        return this.voids.indexOf(name) >= 0;
    }
    isScope(name) {
        return this.scopes.indexOf(name) >= 0;
    }
    popStack() {
        var stack = this.stack;
        stack.pop();
        if (stack.length > 0) {
            this.scope = stack[stack.length - 1].scope;
        }
        else {
            this.scope = "";
        }
    }
}
exports.ParserState = ParserState;

//# sourceMappingURL=parser-state.js.map
