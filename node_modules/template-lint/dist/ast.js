"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(require("./ast/ast-element-attribute"));
__export(require("./ast/ast-element-node"));
__export(require("./ast/ast-node"));
__export(require("./ast/ast-text-node"));
const ast_element_attribute_1 = require("./ast/ast-element-attribute");
const ast_element_node_1 = require("./ast/ast-element-node");
const ast_text_node_1 = require("./ast/ast-text-node");
const ast_node_1 = require("./ast/ast-node");
const rule_1 = require("./rule");
class AST extends rule_1.Rule {
    constructor() {
        super();
        this.root = null;
    }
    init(parser, path) {
        var current = this.root = new ast_node_1.ASTNode();
        parser.on("startTag", (tag, attrs, selfClosing, loc) => {
            if (current == undefined)
                return;
            let next = new ast_element_node_1.ASTElementNode();
            next.tag = tag;
            next.parent = current;
            next.location = { start: loc.startOffset, end: loc.endOffset, line: loc.line, column: loc.col, path: path };
            next.attrs = attrs.map((x, i) => {
                var attr = new ast_element_attribute_1.ASTElementAttribute();
                attr.name = (x.prefix !== undefined && x.prefix != "") ? `${x.prefix}:${x.name}` : x.name;
                var attrLoc = loc.attrs[attr.name] || loc.attrs[attr.name.toLowerCase()];
                if (attrLoc == undefined)
                    attrLoc = { startOffset: -1, endOffset: -1, line: -1, col: -1 };
                attr.location = { start: attrLoc.startOffset, end: attrLoc.endOffset, line: attrLoc.line, column: attrLoc.col, path: path };
                return attr;
            });
            current.children.push(next);
            if (!parser.isVoid(tag))
                current = next;
        });
        parser.on("endTag", (tag, attrs, selfClosing, loc) => {
            if (current == undefined)
                return;
            current = current.parent;
        });
        parser.on("text", (text, loc) => {
            if (current == undefined)
                return;
            let child = new ast_text_node_1.ASTTextNode();
            child.parent = current;
            child.location = { start: loc.startOffset, end: loc.endOffset, line: loc.line, column: loc.col, path: path };
            current.children.push(child);
        });
    }
}
exports.AST = AST;

//# sourceMappingURL=ast.js.map
